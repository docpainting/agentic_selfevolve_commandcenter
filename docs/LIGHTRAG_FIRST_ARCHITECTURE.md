# LightRAG-First Architecture
## Enforcing the Sovereign Record Pattern

**Critical Principle**: LightRAG is the **orchestrator** that creates all nodes, relationships, and UUIDs. Nothing goes directly to Neo4j or ChromaDB - everything flows through LightRAG first.

---

## The Correct Flow

```
ANY DATA (perception, reasoning, code, patterns, etc.)
    â†“
LightRAG (orchestrator)
    â”œâ”€ Extracts entities
    â”œâ”€ Generates UUIDs
    â”œâ”€ Creates embeddings (via Ollama)
    â”œâ”€ Discovers relationships
    â”œâ”€ Constructs nodes
    â†“
    â”œâ”€â†’ ChromaDB (vectors with UUIDs)
    â””â”€â†’ Neo4j (graph with SAME UUIDs)
```

**Never**:
```
âŒ Data â†’ Neo4j directly
âŒ Data â†’ ChromaDB directly
âŒ Manual UUID generation
âŒ Manual relationship creation
```

**Always**:
```
âœ… Data â†’ LightRAG â†’ Neo4j + ChromaDB
âœ… LightRAG generates UUIDs
âœ… LightRAG discovers relationships
âœ… LightRAG creates embeddings
```

---

## Why LightRAG First?

### 1. **Automatic Node Creation**
LightRAG analyzes text and automatically creates:
- `:Entity` nodes (functions, variables, classes)
- `:Concept` nodes (ideas, patterns, theories)
- `:Document` nodes (files, documentation)
- `:Event` nodes (actions, changes, decisions)

### 2. **Automatic Relationship Discovery**
LightRAG finds connections:
- `[:CALLS]` - Function A calls Function B
- `[:DEPENDS_ON]` - Module A depends on Module B
- `[:SIMILAR_TO]` - Pattern A similar to Pattern B
- `[:DERIVED_FROM]` - Concept A derived from Concept B

### 3. **UUID Generation**
LightRAG creates canonical UUIDs:
- Consistent across vector and graph stores
- Enables perfect bidirectional linking
- Supports versioning (`:v1`, `:v2`)

### 4. **Embedding Creation**
LightRAG handles embeddings:
- Uses Ollama with nomic-embed-text:v1.5
- 768 dimensions
- Stores in ChromaDB with UUID metadata

---

## Implementation in MCP Servers

### Dynamic Thinking MCP Server

**File**: `backend/mcp_servers/dynamic_thinking/storage/lightrag_client.py`

```python
from lightrag import LightRAG
from lightrag.llm import ollama_model_complete, ollama_embedding
from lightrag.kg import Neo4jStorage

class LightRAGClient:
    """
    Wrapper around LightRAG that enforces the orchestrator pattern.
    
    ALL data must go through this client - no direct Neo4j/ChromaDB access!
    """
    
    def __init__(self, neo4j_uri: str, neo4j_password: str, ollama_url: str):
        self.rag = LightRAG(
            working_dir="./lightrag_cache",
            llm_model_func=ollama_model_complete,
            llm_model_name="gemma3:27b",
            llm_model_kwargs={
                "host": ollama_url,
                "options": {"num_ctx": 8192}
            },
            embedding_func=ollama_embedding,
            embedding_model_name="nomic-embed-text:v1.5",
            embedding_model_kwargs={
                "host": ollama_url
            },
            kg_storage=Neo4jStorage(
                uri=neo4j_uri,
                user="neo4j",
                password=neo4j_password
            )
        )
    
    async def insert_perception(self, perception_data: dict) -> str:
        """
        Insert perception data through LightRAG.
        
        LightRAG will:
        1. Extract entities (functions, variables, patterns)
        2. Generate UUID for perception
        3. Create embeddings
        4. Store in ChromaDB (with UUID)
        5. Create nodes in Neo4j (with SAME UUID)
        6. Discover relationships
        
        Returns:
            UUID generated by LightRAG
        """
        # Format perception as text for LightRAG
        text = self._format_perception(perception_data)
        
        # Insert through LightRAG (it handles everything)
        result = await self.rag.ainsert(text)
        
        # LightRAG returns the UUID it generated
        return result.uuid
    
    async def insert_reasoning(self, reasoning_data: dict, perception_uuid: str) -> str:
        """
        Insert reasoning data through LightRAG, linked to perception.
        
        Args:
            reasoning_data: The reasoning branches and selected strategy
            perception_uuid: UUID of the perception this reasoning is based on
        
        Returns:
            UUID generated by LightRAG for this reasoning
        """
        # Format reasoning with reference to perception
        text = self._format_reasoning(reasoning_data, perception_uuid)
        
        # Insert through LightRAG
        result = await self.rag.ainsert(text)
        
        # LightRAG automatically creates [:BASED_ON] relationship
        # between reasoning and perception nodes
        return result.uuid
    
    async def insert_action(self, action_data: dict, reasoning_uuid: str) -> str:
        """
        Insert action execution through LightRAG.
        """
        text = self._format_action(action_data, reasoning_uuid)
        result = await self.rag.ainsert(text)
        return result.uuid
    
    async def insert_reflection(self, reflection_data: dict, action_uuid: str) -> str:
        """
        Insert reflection through LightRAG.
        """
        text = self._format_reflection(reflection_data, action_uuid)
        result = await self.rag.ainsert(text)
        return result.uuid
    
    async def query_similar(self, query: str, filters: dict = None) -> list:
        """
        Query for similar content using LightRAG.
        
        LightRAG will:
        1. Create embedding for query
        2. Search ChromaDB for similar vectors
        3. Retrieve full nodes from Neo4j using UUIDs
        4. Expand graph context (relationships)
        5. Return enriched results
        """
        # LightRAG handles the entire retrieval pipeline
        results = await self.rag.aquery(
            query=query,
            param=QueryParam(
                mode="hybrid",  # Vector + graph search
                top_k=10,
                filters=filters
            )
        )
        
        return results
    
    async def get_by_uuid(self, uuid: str) -> dict:
        """
        Retrieve entity by UUID through LightRAG.
        
        LightRAG will:
        1. Query Neo4j for node with this UUID
        2. Retrieve vector from ChromaDB with same UUID
        3. Expand graph context (relationships)
        4. Return complete entity data
        """
        return await self.rag.aget_by_uuid(uuid)
    
    def _format_perception(self, data: dict) -> str:
        """
        Format perception data as text for LightRAG to process.
        
        LightRAG will parse this text and automatically:
        - Extract entity names (HandleTask, database, cache)
        - Create nodes for each entity
        - Discover relationships (HandleTask CALLS database)
        - Generate UUIDs
        """
        return f"""
        Perception of task: {data['task']}
        
        Systems Analysis:
        - Components: {', '.join(data['systems_thinking']['components'])}
        - Bottleneck: {data['systems_thinking']['bottleneck']}
        - Dependencies: {', '.join(data['systems_thinking']['dependencies'])}
        
        Reasoning:
        - Deductive: {data['reasoning']['deductive']['conclusion']}
        - Inductive: {data['reasoning']['inductive']['pattern']}
        - Abductive: {data['reasoning']['abductive']['explanation']}
        
        Confidence: {data['confidence']}
        """
    
    def _format_reasoning(self, data: dict, perception_uuid: str) -> str:
        """
        Format reasoning with reference to perception UUID.
        
        LightRAG will automatically create [:BASED_ON] relationship
        when it sees the UUID reference.
        """
        return f"""
        Reasoning based on perception {perception_uuid}
        
        Branches evaluated:
        {self._format_branches(data['branches'])}
        
        Selected strategy: {data['selected_branch']['strategy']}
        Confidence: {data['selected_branch']['confidence']}
        """
    
    def _format_action(self, data: dict, reasoning_uuid: str) -> str:
        """Format action execution."""
        return f"""
        Action executed based on reasoning {reasoning_uuid}
        
        Plan: {data['plan']}
        Results: {data['results']}
        Performance gain: {data['performance_gain']}
        """
    
    def _format_reflection(self, data: dict, action_uuid: str) -> str:
        """Format reflection."""
        return f"""
        Reflection on action {action_uuid}
        
        Learnings: {', '.join(data['learnings'])}
        Patterns created: {', '.join(data['patterns'])}
        Recommendations: {', '.join(data['recommendations'])}
        """
```

---

## Enforcing LightRAG-First in All Tools

### Perceive Tool

```python
# tools/perceive.py

async def perceive(task_id: str, task: str, goal: str, entity: dict) -> dict:
    """
    Enhanced perception that stores EVERYTHING through LightRAG.
    """
    # 1. Analyze environment (systems thinking, reasoning modes)
    perception_data = await analyze_environment(task, goal, entity)
    
    # 2. Store through LightRAG (NOT directly to Neo4j!)
    lightrag = get_lightrag_client()
    perception_uuid = await lightrag.insert_perception(perception_data)
    
    # 3. Return UUID for next phase
    return {
        "perception_uuid": perception_uuid,
        "data": perception_data,
        "confidence": perception_data['confidence']
    }
```

### Reason Tool

```python
# tools/reason.py

async def reason(perception_uuid: str, task: str) -> dict:
    """
    Multi-branch reasoning that retrieves from and stores to LightRAG.
    """
    lightrag = get_lightrag_client()
    
    # 1. Retrieve perception through LightRAG (NOT directly from Neo4j!)
    perception = await lightrag.get_by_uuid(perception_uuid)
    
    # 2. Query past reasoning through LightRAG
    similar_reasoning = await lightrag.query_similar(
        query=f"reasoning about {task}",
        filters={"type": "reasoning", "success": True}
    )
    
    # 3. Generate reasoning branches
    branches = await generate_branches(perception, similar_reasoning)
    
    # 4. If confidence low, search online
    if branches['confidence'] < 0.6:
        online_info = await search_online(task)
        branches = await regenerate_with_info(branches, online_info)
    
    # 5. Store through LightRAG (NOT directly to Neo4j!)
    reasoning_uuid = await lightrag.insert_reasoning(branches, perception_uuid)
    
    return {
        "reasoning_uuid": reasoning_uuid,
        "branches": branches,
        "selected_branch": branches['selected']
    }
```

### Act Tool

```python
# tools/act.py

async def act(reasoning_uuid: str) -> dict:
    """
    Execute action and store results through LightRAG.
    """
    lightrag = get_lightrag_client()
    
    # 1. Retrieve reasoning through LightRAG
    reasoning = await lightrag.get_by_uuid(reasoning_uuid)
    
    # 2. Execute action plan
    results = await execute_plan(reasoning['selected_branch']['plan'])
    
    # 3. Store through LightRAG
    action_uuid = await lightrag.insert_action(results, reasoning_uuid)
    
    return {
        "action_uuid": action_uuid,
        "results": results
    }
```

### Reflect Tool

```python
# tools/reflect.py

async def reflect(action_uuid: str) -> dict:
    """
    Reflect on action and create patterns through LightRAG.
    """
    lightrag = get_lightrag_client()
    
    # 1. Retrieve complete PRAR chain through LightRAG
    action = await lightrag.get_by_uuid(action_uuid)
    reasoning = await lightrag.get_by_uuid(action['reasoning_uuid'])
    perception = await lightrag.get_by_uuid(reasoning['perception_uuid'])
    
    # 2. Extract learnings
    reflection_data = await extract_learnings(perception, reasoning, action)
    
    # 3. Create patterns (LightRAG will create pattern nodes automatically)
    patterns = await create_patterns(reflection_data)
    
    # 4. Store through LightRAG
    reflection_uuid = await lightrag.insert_reflection(reflection_data, action_uuid)
    
    # 5. Find similar entities for recommendations
    similar_entities = await lightrag.query_similar(
        query=f"entities similar to {perception['entity']}",
        filters={"type": "entity"}
    )
    
    return {
        "reflection_uuid": reflection_uuid,
        "learnings": reflection_data['learnings'],
        "patterns": patterns,
        "recommendations": similar_entities
    }
```

---

## UUID Linking Example

### Complete PRAR Chain

```
Perception UUID: abc-123-def-456
    â†“ (LightRAG creates [:BASED_ON] relationship)
Reasoning UUID: bcd-234-efg-567
    â†“ (LightRAG creates [:EXECUTES] relationship)
Action UUID: cde-345-fgh-678
    â†“ (LightRAG creates [:REFLECTS_ON] relationship)
Reflection UUID: def-456-ghi-789
```

### In Neo4j (Created by LightRAG)

```cypher
(:Perception {uuid: "abc-123-def-456", task: "optimize handler"})
    -[:BASED_ON]->
(:Reasoning {uuid: "bcd-234-efg-567", strategy: "add caching"})
    -[:EXECUTES]->
(:Action {uuid: "cde-345-fgh-678", performance_gain: 0.4})
    -[:REFLECTS_ON]->
(:Reflection {uuid: "def-456-ghi-789", learnings: ["caching works"]})
```

### In ChromaDB (Created by LightRAG)

```python
# All have matching UUIDs!
{
    "uuid": "abc-123-def-456",
    "embedding": [0.123, 0.456, ...],  # 768 dims
    "type": "perception"
}
{
    "uuid": "bcd-234-efg-567",
    "embedding": [0.234, 0.567, ...],
    "type": "reasoning"
}
# ... etc
```

---

## Configuration

**File**: `backend/mcp_servers/dynamic_thinking/config.py`

```python
import os
from lightrag import LightRAG

def get_lightrag_client():
    """
    Get singleton LightRAG client.
    
    This is the ONLY way to access Neo4j and ChromaDB!
    """
    if not hasattr(get_lightrag_client, 'instance'):
        get_lightrag_client.instance = LightRAGClient(
            neo4j_uri=os.getenv("NEO4J_URI", "bolt://localhost:7687"),
            neo4j_password=os.getenv("NEO4J_PASSWORD"),
            ollama_url=os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
        )
    
    return get_lightrag_client.instance
```

---

## Enforcement Rules

### Rule 1: No Direct Database Access
```python
# âŒ WRONG - Direct Neo4j access
from neo4j import GraphDatabase
driver = GraphDatabase.driver(uri, auth=(user, password))
session = driver.session()
session.run("CREATE (n:Perception {uuid: '...'})")  # FORBIDDEN!

# âœ… CORRECT - Through LightRAG
lightrag = get_lightrag_client()
uuid = await lightrag.insert_perception(data)  # LightRAG creates the node
```

### Rule 2: No Manual UUID Generation
```python
# âŒ WRONG - Manual UUID
import uuid
perception_uuid = str(uuid.uuid4())  # FORBIDDEN!

# âœ… CORRECT - LightRAG generates UUID
uuid = await lightrag.insert_perception(data)  # LightRAG generates UUID
```

### Rule 3: No Manual Relationship Creation
```python
# âŒ WRONG - Manual relationship
session.run("""
    MATCH (p:Perception {uuid: $p_uuid})
    MATCH (r:Reasoning {uuid: $r_uuid})
    CREATE (r)-[:BASED_ON]->(p)
""")  # FORBIDDEN!

# âœ… CORRECT - LightRAG discovers relationships
# Just reference the UUID in the text, LightRAG handles the rest
text = f"Reasoning based on perception {perception_uuid}"
await lightrag.insert_reasoning(text)  # LightRAG creates relationship
```

---

## Benefits of LightRAG-First

### 1. **Consistency**
- UUIDs always match between vector and graph
- Relationships are automatically discovered
- No manual sync needed

### 2. **Simplicity**
- One API for all storage
- No need to manage Neo4j and ChromaDB separately
- Automatic embedding creation

### 3. **Intelligence**
- LightRAG understands context
- Discovers relationships automatically
- Creates semantic graph structure

### 4. **Safety**
- Single source of truth
- Atomic operations
- No partial writes

---

## Summary

### The Golden Rule

**Everything goes through LightRAG first!**

```
âœ… Data â†’ LightRAG â†’ Neo4j + ChromaDB
âŒ Data â†’ Neo4j directly
âŒ Data â†’ ChromaDB directly
```

### What LightRAG Handles Automatically

1. âœ… Entity extraction
2. âœ… UUID generation
3. âœ… Embedding creation
4. âœ… Relationship discovery
5. âœ… Node creation in Neo4j
6. âœ… Vector storage in ChromaDB
7. âœ… Graph expansion
8. âœ… Hybrid search (vector + graph)

### What You Never Do Manually

1. âŒ Create Neo4j nodes directly
2. âŒ Generate UUIDs yourself
3. âŒ Create relationships manually
4. âŒ Store vectors directly
5. âŒ Manage sync between stores

**LightRAG is the sovereign orchestrator - respect it!** ğŸ¯

