package agent

import (
	"context"
	"encoding/json"
	"fmt"

	"agent-workspace/backend/pkg/models"
	"agent-workspace/backend/pkg/ollama"
)

// EvoXAdapter wraps Gemma 3 to be compatible with EvoAgentX framework
// EvoAgentX expects LLMs to implement: generate(), generate_async(), and structured output parsing
// This adapter provides the bridge between our Ollama-based Gemma client and EvoX expectations
type EvoXAdapter struct {
	gemma  *GemmaClient
	ollama *ollama.Client
}

// NewEvoXAdapter creates a new EvoX-compatible adapter
func NewEvoXAdapter(gemma *GemmaClient, ollama *ollama.Client) *EvoXAdapter {
	return &EvoXAdapter{
		gemma:  gemma,
		ollama: ollama,
	}
}

// Generate provides synchronous generation compatible with EvoAgentX
// EvoAgentX calls this with: generate(prompt, temperature, max_tokens, stop_sequences)
func (e *EvoXAdapter) Generate(ctx context.Context, prompt string, temperature float64, maxTokens int) (string, error) {
	messages := []models.Message{
		{
			Role: "user",
			Parts: []models.MessagePart{
				{Type: "text", Text: prompt},
			},
		},
	}

	return e.gemma.GenerateResponse(ctx, messages, temperature)
}

// GenerateStream provides streaming generation compatible with EvoAgentX
// EvoAgentX uses this for real-time output during agent execution
func (e *EvoXAdapter) GenerateStream(ctx context.Context, prompt string, temperature float64, callback func(string) error) error {
	messages := []models.Message{
		{
			Role: "user",
			Parts: []models.MessagePart{
				{Type: "text", Text: prompt},
			},
		},
	}

	return e.gemma.GenerateResponseStream(ctx, messages, temperature, callback)
}

// GenerateStructured generates structured output (JSON) compatible with EvoAgentX
// EvoAgentX uses this for workflow generation, action parsing, and evaluation
func (e *EvoXAdapter) GenerateStructured(ctx context.Context, prompt string, schema interface{}, temperature float64) (interface{}, error) {
	// Add JSON schema instruction to prompt
	schemaJSON, err := json.Marshal(schema)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal schema: %w", err)
	}

	structuredPrompt := fmt.Sprintf(`%s

IMPORTANT: Respond with valid JSON matching this schema:
%s

Return ONLY the JSON, no additional text.`, prompt, string(schemaJSON))

	// Generate response
	response, err := e.Generate(ctx, structuredPrompt, temperature, 0)
	if err != nil {
		return nil, err
	}

	// Parse JSON response
	var result interface{}
	if err := json.Unmarshal([]byte(response), &result); err != nil {
		return nil, fmt.Errorf("failed to parse structured response: %w", err)
	}

	return result, nil
}

// EvoXWorkflowRequest represents a workflow generation request from EvoAgentX
type EvoXWorkflowRequest struct {
	Goal        string   `json:"goal"`
	Constraints []string `json:"constraints,omitempty"`
	Tools       []string `json:"tools,omitempty"`
}

// EvoXWorkflowResponse represents the workflow generated by EvoAgentX
type EvoXWorkflowResponse struct {
	Nodes []EvoXNode `json:"nodes"`
	Edges []EvoXEdge `json:"edges"`
}

// EvoXNode represents an agent node in the workflow
type EvoXNode struct {
	ID          string                 `json:"id"`
	Type        string                 `json:"type"` // "agent", "tool", "evaluator"
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Config      map[string]interface{} `json:"config"`
}

// EvoXEdge represents a connection between nodes
type EvoXEdge struct {
	From string `json:"from"`
	To   string `json:"to"`
	Type string `json:"type"` // "sequential", "conditional", "parallel"
}

// GenerateWorkflow generates an EvoAgentX-compatible workflow
// This is called by EvoAgentX's WorkFlowGenerator
func (e *EvoXAdapter) GenerateWorkflow(ctx context.Context, request EvoXWorkflowRequest) (*EvoXWorkflowResponse, error) {
	prompt := fmt.Sprintf(`Generate a multi-agent workflow to achieve this goal:

Goal: %s

Available tools: %v
Constraints: %v

Create a workflow with nodes (agents/tools) and edges (connections).
Each node should have a clear purpose and configuration.
Return the workflow as JSON.`, request.Goal, request.Tools, request.Constraints)

	schema := EvoXWorkflowResponse{
		Nodes: []EvoXNode{
			{
				ID:          "example",
				Type:        "agent",
				Name:        "Example Agent",
				Description: "Description of what this agent does",
				Config:      map[string]interface{}{"key": "value"},
			},
		},
		Edges: []EvoXEdge{
			{From: "node1", To: "node2", Type: "sequential"},
		},
	}

	result, err := e.GenerateStructured(ctx, prompt, schema, 0.7)
	if err != nil {
		return nil, err
	}

	// Convert result to workflow response
	workflowJSON, err := json.Marshal(result)
	if err != nil {
		return nil, err
	}

	var workflow EvoXWorkflowResponse
	if err := json.Unmarshal(workflowJSON, &workflow); err != nil {
		return nil, err
	}

	return &workflow, nil
}

// EvoXActionRequest represents an action parsing request
type EvoXActionRequest struct {
	Observation string   `json:"observation"`
	Goal        string   `json:"goal"`
	History     []string `json:"history"`
}

// EvoXAction represents a parsed action
type EvoXAction struct {
	Type       string                 `json:"type"` // "browser", "terminal", "mcp", etc.
	Command    string                 `json:"command"`
	Parameters map[string]interface{} `json:"parameters"`
	Reasoning  string                 `json:"reasoning"`
}

// ParseAction parses the next action from observation
// This is used by EvoAgentX agents to decide what to do next
func (e *EvoXAdapter) ParseAction(ctx context.Context, request EvoXActionRequest) (*EvoXAction, error) {
	prompt := fmt.Sprintf(`Based on this observation, determine the next action:

Observation: %s
Goal: %s
Previous actions: %v

What should the agent do next? Consider:
- Browser actions (navigate, click, type)
- Terminal commands
- MCP tool calls
- Memory operations

Return the action as JSON with type, command, parameters, and reasoning.`, 
		request.Observation, request.Goal, request.History)

	schema := EvoXAction{
		Type:       "browser",
		Command:    "navigate",
		Parameters: map[string]interface{}{"url": "https://example.com"},
		Reasoning:  "Explanation of why this action is chosen",
	}

	result, err := e.GenerateStructured(ctx, prompt, schema, 0.5)
	if err != nil {
		return nil, err
	}

	actionJSON, err := json.Marshal(result)
	if err != nil {
		return nil, err
	}

	var action EvoXAction
	if err := json.Unmarshal(actionJSON, &action); err != nil {
		return nil, err
	}

	return &action, nil
}

// EvoXEvaluationRequest represents an evaluation request
type EvoXEvaluationRequest struct {
	Task   string `json:"task"`
	Result string `json:"result"`
	Goal   string `json:"goal"`
}

// EvoXEvaluation represents an evaluation result
type EvoXEvaluation struct {
	Score     float64  `json:"score"`      // 0.0 to 1.0
	Feedback  string   `json:"feedback"`   // Detailed feedback
	Strengths []string `json:"strengths"`  // What went well
	Weaknesses []string `json:"weaknesses"` // What needs improvement
	Suggestions []string `json:"suggestions"` // How to improve
}

// Evaluate evaluates task execution
// This is used by EvoAgentX's self-evolution engine to improve workflows
func (e *EvoXAdapter) Evaluate(ctx context.Context, request EvoXEvaluationRequest) (*EvoXEvaluation, error) {
	prompt := fmt.Sprintf(`Evaluate this task execution:

Task: %s
Goal: %s
Result: %s

Provide:
1. Score (0.0 to 1.0) - how well the goal was achieved
2. Feedback - detailed analysis
3. Strengths - what worked well
4. Weaknesses - what didn't work
5. Suggestions - how to improve

Return as JSON.`, request.Task, request.Goal, request.Result)

	schema := EvoXEvaluation{
		Score:       0.8,
		Feedback:    "Detailed evaluation feedback",
		Strengths:   []string{"Strength 1", "Strength 2"},
		Weaknesses:  []string{"Weakness 1"},
		Suggestions: []string{"Suggestion 1", "Suggestion 2"},
	}

	result, err := e.GenerateStructured(ctx, prompt, schema, 0.3)
	if err != nil {
		return nil, err
	}

	evalJSON, err := json.Marshal(result)
	if err != nil {
		return nil, err
	}

	var evaluation EvoXEvaluation
	if err := json.Unmarshal(evalJSON, &evaluation); err != nil {
		return nil, err
	}

	return &evaluation, nil
}

// GetModelInfo returns model information for EvoAgentX
func (e *EvoXAdapter) GetModelInfo() map[string]interface{} {
	return map[string]interface{}{
		"name":         "gemma3:27b",
		"provider":     "ollama",
		"context_size": 8192,
		"capabilities": []string{
			"text_generation",
			"structured_output",
			"streaming",
			"function_calling",
		},
	}
}

// SupportsStreaming returns whether streaming is supported
func (e *EvoXAdapter) SupportsStreaming() bool {
	return true
}

// SupportsStructuredOutput returns whether structured output is supported
func (e *EvoXAdapter) SupportsStructuredOutput() bool {
	return true
}

// Integration with existing Controller
// Add this method to your Controller struct

// GetEvoXAdapter returns an EvoX-compatible adapter
func (c *Controller) GetEvoXAdapter() *EvoXAdapter {
	return NewEvoXAdapter(c.gemma, c.ollama)
}

// Example usage in your agent system:
//
// // Initialize controller
// controller := agent.NewController(...)
//
// // Get EvoX adapter
// evoxAdapter := controller.GetEvoXAdapter()
//
// // Use with EvoAgentX
// workflow, err := evoxAdapter.GenerateWorkflow(ctx, agent.EvoXWorkflowRequest{
//     Goal: "Find information about LightRAG on GitHub",
//     Tools: []string{"browser", "terminal", "mcp"},
// })
//
// // Parse actions
// action, err := evoxAdapter.ParseAction(ctx, agent.EvoXActionRequest{
//     Observation: "Browser shows GitHub search results",
//     Goal: "Find LightRAG repository",
//     History: []string{"navigated to github.com", "searched for lightrag"},
// })
//
// // Evaluate results
// evaluation, err := evoxAdapter.Evaluate(ctx, agent.EvoXEvaluationRequest{
//     Task: "Find LightRAG repository",
//     Goal: "Locate the go-light-rag repository by MegaGrindStone",
//     Result: "Successfully found and navigated to the repository",
// })

